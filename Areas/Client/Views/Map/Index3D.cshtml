@model Semester03.Areas.Client.Models.ViewModels.MapViewModel
@{
    Layout = "_LayoutClient";
    // constants & data
    var shopHeightMeters = 5m;
    var elevatorHeightMeters = 8m;
    var planWidthMeters = 120m;
    var planDepthMeters = 80m;
    var vbW = 1200m; var vbH = 800m;
    var atrX = 460m; var atrY = 260m; var atrW = 280m; var atrH = 180m;
    var elevW = 48m;
    var elevH = atrH - 20m;
    var elevY = atrY + 10m;
    var elev1X = atrX + 20m;
    var elev2X = atrX + atrW - 20m - elevW;
    var wcX = 1020m; var wcY = 320m;

    var positions = Model?.Positions ?? new List<Semester03.Areas.Client.Models.ViewModels.TenantPositionDto>();
    var floorList = positions.Select(p => p.TenantPosition_Floor).Distinct().OrderBy(x => x).ToList();
    int? currentFloor = Model?.FloorNumber;
}

<div class="container py-3">
    <div class="d-flex justify-content-between align-items-center mb-2">
        <div>
            <h4 class="mb-0">Mô phỏng 3D sơ đồ — @(currentFloor.HasValue ? (currentFloor == 0 ? "G (0)" : "Tầng " + currentFloor.ToString()) : "Tất cả")</h4>
            <small class="text-muted">Giao diện 3D phong cách VIP — kéo/phóng/điều khiển camera, click để mở modal thông tin.</small>
        </div>

        <div class="d-flex gap-2 align-items-center">
            <select id="floorSelect" class="form-select form-select-sm" style="min-width:160px;">
                <option value="ALL" @(currentFloor == null ? "selected" : "")>Tất cả tầng (Toàn Mall)</option>
                @foreach (var f in floorList)
                {
                    <option value="@f" @(currentFloor.HasValue && currentFloor.Value == f ? "selected" : "")>@(f == 0 ? "G (0)" : "Tầng " + f)</option>
                }
            </select>
        </div>
    </div>

    <div class="card p-0">
        <div id="threeContainer" style="height:820px; width:100%; position:relative;"></div>

        <div class="p-2">
            <div class="d-flex gap-3 align-items-center flex-wrap">
                <div class="form-check form-check-inline ms-auto">
                    <input class="form-check-input" type="checkbox" id="chkShowEmpty" checked>
                    <label class="form-check-label small" for="chkShowEmpty">Hiện vị trí trống</label>
                </div>

                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" id="chkShowOccupied" checked>
                    <label class="form-check-label small" for="chkShowOccupied">Hiện có tenant</label>
                </div>
            </div>
        </div>
    </div>
</div>

@* modal cho 3D click *@
<div class="modal fade" id="posModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-md modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Thông tin ô</h5>
                <button class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body" id="posModalBody">
                <div class="text-center py-3 text-muted">Đang tải...</div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" data-bs-dismiss="modal">Đóng</button>
            </div>
        </div>
    </div>
</div>

@section Styles {
    <style>
        #threeContainer {
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 12px 40px rgba(7,18,30,0.08);
        }

        .label-2d {
            font-family: Inter, Roboto, Arial, sans-serif;
            font-size: 13px;
            padding: 6px 10px;
            background: rgba(255,255,255,0.98);
            border-radius: 6px;
            color: #071221;
            font-weight: 700;
            border: 1px solid rgba(0,0,0,0.06);
            box-shadow: 0 8px 22px rgba(7,18,30,0.08);
        }

        .label-wc {
            font-size: 12px;
            padding: 6px 8px;
            border-radius: 6px;
            background: rgba(255,240,240,0.95);
            color: #8b2b2b;
            font-weight: 700;
        }

        .elev-badge {
            font-size: 12px;
            padding: 4px 8px;
            background: rgba(0,0,0,0.6);
            color: white;
            border-radius: 6px;
        }
    </style>
}

@section Scripts {
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>

    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
            "three/examples/jsm/": "https://unpkg.com/three@0.154.0/examples/jsm/"
          }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer.js';

        // server-injected constants (numbers)
        const shopHeightMeters = @((double)shopHeightMeters);
        const elevatorHeightMeters = @((double)elevatorHeightMeters);
        const planWidthMeters = @((double)planWidthMeters);
        const planDepthMeters = @((double)planDepthMeters);
        const vbW = @((double)vbW);
        const vbH = @((double)vbH);
        const atrX = @((double)atrX);
        const atrY = @((double)atrY);
        const atrW = @((double)atrW);
        const atrH = @((double)atrH);
        const elevW = @((double)elevW);
        const elevH = @((double)elevH);
        const elevY = @((double)elevY);
        const elev1X = @((double)elev1X);
        const elev2X = @((double)elev2X);
        const wcX = @((double)wcX);
        const wcY = @((double)wcY);

        // positions and floor list
        const allPositions = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(positions));
        const floorList = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(floorList));
        let currentFloor = @(currentFloor.HasValue ? currentFloor.Value.ToString() : "null");

        // helpers: coords conversion
        function leftPctToX(leftPct){ return (leftPct/100.0) * planWidthMeters - planWidthMeters/2.0; }
        function topPctToZ(topPct){ return (topPct/100.0) * planDepthMeters - planDepthMeters/2.0; }
        function svgToMeterX(svgX){ return (svgX / vbW) * planWidthMeters - planWidthMeters/2.0; }
        function svgToMeterZ(svgY){ return (svgY / vbH) * planDepthMeters - planDepthMeters/2.0; }

        // atrium bounds (meters) for exclusion test
        const atriumWidthMeters = (atrW / vbW * planWidthMeters);
        const atriumDepthMeters = (atrH / vbH * planDepthMeters);
        const atriumCenterX = ((atrX + atrW/2.0) / vbW * planWidthMeters) - planWidthMeters/2.0;
        const atriumCenterZ = ((atrY + atrH/2.0) / vbH * planDepthMeters) - planDepthMeters/2.0;
        const atriumHalfW = atriumWidthMeters / 2.0;
        const atriumHalfD = atriumDepthMeters / 2.0;

        // Scene + renderers
        const container = document.getElementById('threeContainer');
        const scene = new THREE.Scene(); scene.background = new THREE.Color(0xf6fbff);

        const renderer = new THREE.WebGLRenderer({ antialias:true, physicallyCorrectLights:true });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(container.clientWidth, container.clientHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0';
        labelRenderer.domElement.style.left = '0';
        labelRenderer.domElement.style.pointerEvents = 'none';
        container.appendChild(labelRenderer.domElement);

        // Camera / controls
        const camera = new THREE.PerspectiveCamera(50, container.clientWidth/container.clientHeight, 0.1, 5000);
        camera.position.set(0, 160, 260);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.08;
        controls.screenSpacePanning = false;
        controls.minDistance = 40; controls.maxDistance = 1200;
        controls.maxPolarAngle = Math.PI * 0.49;
        controls.target.set(0, 30, 0);
        controls.update();

        // Lighting (VIP-ish)
        scene.add(new THREE.AmbientLight(0xffffff, 0.45));
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444b5a, 0.25));
        const dir = new THREE.DirectionalLight(0xffffff, 0.9);
        dir.position.set(120,400,160);
        dir.castShadow = true;
        dir.shadow.mapSize.set(2048,2048);
        scene.add(dir);

        // ground + grid
        const groundGeom = new THREE.PlaneGeometry(planWidthMeters, planDepthMeters);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness:0.03, roughness:0.86 });
        const ground = new THREE.Mesh(groundGeom, groundMat); ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
        const grid = new THREE.GridHelper(Math.max(planWidthMeters, planDepthMeters), 12, 0xe9eef3, 0xe9eef3); grid.position.y = 0.01; scene.add(grid);

        // floor separators & skylight & full atrium walls (unchanged idea)
        const gap = 1.0;
        const maxFloor = (floorList && floorList.length>0) ? Math.max(...floorList,0) : 0;
        const floorsCount = Math.max(1, maxFloor + 1);
        const totalHeight = floorsCount * (shopHeightMeters + gap);

        const separatorsGroup = new THREE.Group(); scene.add(separatorsGroup);
        for (let f=1; f<=maxFloor; f++){
          const y = f * (shopHeightMeters + gap) - gap/2.0;
          const matVis = new THREE.MeshStandardMaterial({ color: 0x0b1724, transparent:true, opacity:0.12, side: THREE.DoubleSide });
          const plane = new THREE.Mesh(new THREE.PlaneGeometry(planWidthMeters, planDepthMeters), matVis);
          plane.rotation.x = -Math.PI/2;
          plane.position.y = y;
          separatorsGroup.add(plane);
          // 2D label
          const div = document.createElement('div'); div.className='label-2d'; div.textContent = `Tầng ${f}`;
          const lbl = new CSS2DObject(div);
          lbl.position.set(-planWidthMeters/2 + 6, y + 0.4, -planDepthMeters/2 + 6);
          scene.add(lbl);
        }

        // Atrium walls + skylight spanning floors
        (function addAtriumWallsAndSkylight(){
          const wallThickness = 0.6;
          const sideMat = new THREE.MeshStandardMaterial({ color:0xfff6eb, transparent:true, opacity:0.95, roughness:0.6 });
          const north = new THREE.Mesh(new THREE.BoxGeometry(atriumWidthMeters, totalHeight + 0.2, wallThickness), sideMat);
          north.position.set(atriumCenterX, (totalHeight)/2.0, atriumCenterZ - atriumHalfD + wallThickness/2); scene.add(north);
          const south = new THREE.Mesh(new THREE.BoxGeometry(atriumWidthMeters, totalHeight + 0.2, wallThickness), sideMat);
          south.position.set(atriumCenterX, (totalHeight)/2.0, atriumCenterZ + atriumHalfD - wallThickness/2); scene.add(south);
          const west = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, totalHeight + 0.2, atriumDepthMeters), sideMat);
          west.position.set(atriumCenterX - atriumHalfW + wallThickness/2, (totalHeight)/2.0, atriumCenterZ); scene.add(west);
          const east = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, totalHeight + 0.2, atriumDepthMeters), sideMat);
          east.position.set(atriumCenterX + atriumHalfW - wallThickness/2, (totalHeight)/2.0, atriumCenterZ); scene.add(east);

          // skylight (roof)
          const skylightMat = new THREE.MeshPhysicalMaterial({ color:0xeef8ff, transparent:true, opacity:0.14, roughness:0.1, clearcoat:0.3 });
          const skylight = new THREE.Mesh(new THREE.PlaneGeometry(atriumWidthMeters, atriumDepthMeters), skylightMat);
          skylight.rotation.x = -Math.PI/2;
          skylight.position.set(atriumCenterX, totalHeight + 0.5, atriumCenterZ);
          scene.add(skylight);
        })();

        // elevator shafts + per-floor cone markers
        const elevatorsGroup = new THREE.Group(); scene.add(elevatorsGroup);
        (function addElevatorsShafts(){
          const e1center = svgToMeterX(elev1X + elevW/2.0);
          const e2center = svgToMeterX(elev2X + elevW/2.0);
          const eZ = svgToMeterZ(elevY + elevH/2.0);
          const shaftGeom = new THREE.BoxGeometry(4, totalHeight + 0.4, 4.0);
          const shaftMat = new THREE.MeshStandardMaterial({ color:0x222a35, transparent:true, opacity:0.12, roughness:0.5 });
          const s1 = new THREE.Mesh(shaftGeom, shaftMat); s1.position.set(e1center, totalHeight/2.0, eZ); s1.receiveShadow=true; elevatorsGroup.add(s1);
          const s2 = new THREE.Mesh(shaftGeom, shaftMat); s2.position.set(e2center, totalHeight/2.0, eZ); s2.receiveShadow=true; elevatorsGroup.add(s2);
          const coneGeom = new THREE.ConeGeometry(1.2, 2.4, 16);
          const coneUpMat = new THREE.MeshStandardMaterial({ color:0x16a34a, emissive:0x16a34a, emissiveIntensity:0.2 });
          const coneDownMat = new THREE.MeshStandardMaterial({ color:0xf39c12, emissive:0xf39c12, emissiveIntensity:0.2 });
          for (let f=0; f< floorsCount; f++){
            const baseY = f * (shopHeightMeters + gap);
            const c1 = new THREE.Mesh(coneGeom, (f%2===0)?coneUpMat:coneDownMat);
            c1.position.set(e1center, baseY + shopHeightMeters + 0.8, eZ); if (f%2===0) c1.rotation.x = Math.PI;
            elevatorsGroup.add(c1);
            const c2 = new THREE.Mesh(coneGeom, (f%2===0)?coneUpMat:coneDownMat);
            c2.position.set(e2center, baseY + shopHeightMeters + 0.8, eZ); if (f%2===0) c2.rotation.x = Math.PI;
            elevatorsGroup.add(c2);
          }
        })();

        // WC per-floor
        const wcGroup = new THREE.Group(); scene.add(wcGroup);
        (function addWCPerFloor(){
          const wcXm = svgToMeterX(wcX);
          const wcZm = svgToMeterZ(wcY);
          for (let f=0; f< floorsCount; f++){
            const baseY = f * (shopHeightMeters + gap);
            const geom = new THREE.BoxGeometry(6, 3.0, 4.0);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffecec, metalness:0.0, roughness:0.5 });
            const wc = new THREE.Mesh(geom, mat); wc.position.set(wcXm, baseY + 1.5, wcZm);
            wc.userData = { type:'wc', floor: f }; wc.receiveShadow=true; wc.castShadow=true;
            wcGroup.add(wc);
            const div = document.createElement('div'); div.className='label-wc'; div.textContent = 'WC';
            const lbl = new CSS2DObject(div); lbl.position.set(0, 1.8, 0); wc.add(lbl);
          }
        })();

        // ---------------------------
        // SHOPS: robust create / destroy
        // ---------------------------

        // helper to remove CSS2D DOM elements attached to objects (recursive)
        function remove2DLabelsRecursively(obj){
          if (!obj) return;
          if (obj.element && obj.element.parentNode){
            // CSS2DObject exposes .element
            try { obj.element.parentNode.removeChild(obj.element); } catch(e){ /* ignore */ }
          }
          if (obj.children && obj.children.length){
            for (let i=0;i<obj.children.length;i++) remove2DLabelsRecursively(obj.children[i]);
          }
        }

        // factory to create new shopsGroup (we always replace the old one)
        let shopsGroup = null;
        function createNewShopsGroup(){
          // remove old group and free resources
          if (shopsGroup){
            // remove any CSS2D elements attached under old group
            shopsGroup.children.forEach(c => remove2DLabelsRecursively(c));
            // dispose geometry and material
            shopsGroup.traverse(node => {
              if (node.geometry){ node.geometry.dispose(); }
              if (node.material){ if (Array.isArray(node.material)) node.material.forEach(m => m.dispose && m.dispose()); else node.material.dispose && node.material.dispose(); }
            });
            scene.remove(shopsGroup);
            shopsGroup = null;
          }
          shopsGroup = new THREE.Group();
          scene.add(shopsGroup);
          return shopsGroup;
        }

        function isInsideAtrium(x,z,halfW,halfD){
          return (Math.abs(x - atriumCenterX) < (atriumHalfW - halfW)) && (Math.abs(z - atriumCenterZ) < (atriumHalfD - halfD));
        }

        // build shops for `forFloorsArray` (empty array means ALL floors)
        function buildShops(forFloorsArray){
          // recreate shopsGroup from scratch (ensures nothing old remains)
          createNewShopsGroup();

          let list = [];
          if (!forFloorsArray || forFloorsArray.length === 0){
            if (currentFloor !== null) list = allPositions.filter(p => parseInt(p.TenantPosition_Floor ?? 0) === parseInt(currentFloor));
            else list = allPositions.slice();
          } else {
            list = allPositions.filter(p => forFloorsArray.includes(parseInt(p.TenantPosition_Floor ?? 0)));
          }

          list.forEach(p => {
            const leftPct = parseFloat(p.TenantPosition_LeftPct ?? 0);
            const topPct = parseFloat(p.TenantPosition_TopPct ?? 0);
            const floor = parseInt(p.TenantPosition_Floor ?? 0);
            const area = parseFloat(p.TenantPosition_Area_M2 ?? 150);
            const assigned = !!(p.TenantPosition_AssignedTenantID && p.TenantPosition_AssignedTenantID > 0);
            const labelText = (p.Tenant && p.Tenant.Tenant_Name) ? p.Tenant.Tenant_Name : (p.TenantPosition_Location || "Trống");

            // center in meters
            const x = leftPctToX(leftPct);
            const z = topPctToZ(topPct);

            // estimate extents for atrium collision
            const w = Math.max(6.0, Math.sqrt(area) * 0.9);
            const d = Math.max(4.0, area / w);
            const halfW = w/2.0;
            const halfD = d/2.0;

            // skip shops whose centers fall into the atrium inner area -> ensures no shop sits inside atrium
            if (isInsideAtrium(x, z, halfW, halfD)) {
              return;
            }

            const h = shopHeightMeters;
            const geom = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshStandardMaterial({ color: assigned ? 0x2b6cb0 : 0xffffff, roughness:0.45, metalness:0.02 });
            const mesh = new THREE.Mesh(geom, mat); mesh.castShadow=true; mesh.receiveShadow=true;
            const baseY = floor * (shopHeightMeters + gap);
            mesh.position.set(x, baseY + h/2.0, z);
            mesh.userData = { id: p.TenantPosition_ID, floor: floor, assigned: assigned, label: labelText };

            // label (CSS2D)
            const div = document.createElement('div'); div.className='label-2d'; div.textContent = `Tầng ${floor} - ${labelText}`;
            const label = new CSS2DObject(div);
            label.position.set(0, h/2 + 0.6, 0);
            mesh.add(label);

            shopsGroup.add(mesh);
          });
        }

        // ---------------------------
        // UI: select + checkboxes (robust)
        // ---------------------------
        const floorSelect = document.getElementById('floorSelect');
        const chkShowEmpty = document.getElementById('chkShowEmpty');
        const chkShowOcc = document.getElementById('chkShowOccupied');

        // read selection; supports 'ALL' or numeric values
        function getSelectedFloorsFromSelect(){
          if (!floorSelect) return (currentFloor !== null) ? [parseInt(currentFloor)] : [];
          const val = floorSelect.value;
          if (!val) return (currentFloor !== null) ? [parseInt(currentFloor)] : [];
          if (String(val).toUpperCase() === 'ALL') return [];
          const n = parseInt(val);
          return isNaN(n) ? [] : [n];
        }

        function applyFiltersFromSelect(){
          // set currentFloor (null if ALL)
          if (floorSelect){
            currentFloor = (String(floorSelect.value).toUpperCase() === 'ALL') ? null : (isNaN(parseInt(floorSelect.value)) ? null : parseInt(floorSelect.value));
          }
          const floors = getSelectedFloorsFromSelect();
          buildShops(floors);

          // occupation toggles
          const showEmpty = chkShowEmpty ? chkShowEmpty.checked : true;
          const showOcc = chkShowOcc ? chkShowOcc.checked : true;
          if (shopsGroup && shopsGroup.children){
            shopsGroup.children.forEach(m => {
              const assigned = m.userData && m.userData.assigned;
              let visible = true;
              if (!showEmpty && !assigned) visible = false;
              if (!showOcc && assigned) visible = false;
              m.visible = visible;
            });
          }
        }

        // init defaults
        if (floorSelect){
          if (currentFloor !== null) floorSelect.value = String(currentFloor); else {
            // add ALL option fallback (if you want ALL)
            // if select has no ALL, just leave as-is
            try { floorSelect.querySelector('option[value="ALL"]').selected = true; } catch(e) {}
          }
          applyFiltersFromSelect();
        }

        // wire UI events
        if (floorSelect) floorSelect.addEventListener('change', applyFiltersFromSelect);
        if (chkShowEmpty) chkShowEmpty.addEventListener('change', applyFiltersFromSelect);
        if (chkShowOcc) chkShowOcc.addEventListener('change', applyFiltersFromSelect);

        // ---------------------------
        // Raycast hover & click (uses the shopsGroup variable which we recreate safely)
        // ---------------------------
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let hovered = null;
        const modal = new bootstrap.Modal(document.getElementById('posModal'));
        const modalBody = document.getElementById('posModalBody');

        function onPointerMove(e){
          const rect = renderer.domElement.getBoundingClientRect();
          pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
          pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
          raycaster.setFromCamera(pointer, camera);
          if (!shopsGroup) return;
          const intersects = raycaster.intersectObjects(shopsGroup.children, true);
          if (intersects.length > 0){
            const mesh = intersects[0].object;
            if (hovered !== mesh){
              clearHover(); setHover(mesh);
            }
          } else clearHover();
        }

        function setHover(mesh){
          if (!mesh || !mesh.userData) return;
          hovered = mesh;
          if (mesh.material && mesh.material.emissive !== undefined){
            mesh.userData.prevEm = mesh.material.emissive.clone();
            mesh.material.emissive.setHex(0x2266ff);
          } else if (mesh.material && mesh.material.color){
            mesh.userData.prevColor = mesh.material.color.getHex();
            mesh.material.color.setHex(0xffe58a);
          }
          mesh.userData.prevScale = mesh.scale.clone();
          mesh.scale.set(mesh.scale.x*1.04, mesh.scale.y*1.04, mesh.scale.z*1.04);
          renderer.domElement.style.cursor = 'pointer';
        }

        function clearHover(){
          if (!hovered) return;
          const m = hovered;
          if (m.material && m.material.emissive !== undefined && m.userData.prevEm){
            m.material.emissive.copy(m.userData.prevEm);
            delete m.userData.prevEm;
          }
          if (m.material && m.material.color && m.userData.prevColor){
            m.material.color.setHex(m.userData.prevColor);
            delete m.userData.prevColor;
          }
          if (m.userData.prevScale) { m.scale.copy(m.userData.prevScale); delete m.userData.prevScale; }
          hovered = null; renderer.domElement.style.cursor = 'default';
        }

        function onClick(e){
          if (!shopsGroup) return;
          const rect = renderer.domElement.getBoundingClientRect();
          pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
          pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
          raycaster.setFromCamera(pointer, camera);
          const intersects = raycaster.intersectObjects(shopsGroup.children, true);
          if (intersects.length > 0){
            const mesh = intersects[0].object;
            const id = mesh.userData && mesh.userData.id;
            if (id && id>0){
              const url = '@Url.Action("GetPositionJson", "Map", new { area = "Client" })';
              modalBody.innerHTML = '<div class="text-center py-3"><div class="spinner-border text-primary" role="status"></div><div class="mt-2 text-muted">Đang tải...</div></div>';
              modal.show();
              fetch(url + '?id=' + id).then(r=>{ if(!r.ok) throw new Error('notfound'); return r.json(); })
              .then(data => {
                let html = '<div class="d-flex gap-3">';
                if (data.Tenant && data.Tenant.Tenant_Img) html += '<div style="flex:0 0 96px"><img src="' + data.Tenant.Tenant_Img + '" class="img-fluid rounded" /></div><div style="flex:1">';
                else html += '<div style="flex:1">';
                html += '<h5 class="mb-1">' + (data.Tenant && data.Tenant.Tenant_Name ? data.Tenant.Tenant_Name : (data.TenantPosition_Location || 'Vị trí')) + '</h5>';
                if (data.Tenant && data.Tenant.Tenant_Description) html += '<div class="text-muted small mb-2">' + data.Tenant.Tenant_Description + '</div>';
                if (data.Tenant && data.Tenant.TenantType_Name) html += '<div class="small text-secondary">Loại: ' + data.Tenant.TenantType_Name + '</div>';
                html += '<div class="small text-muted mt-2">Diện tích: ' + (data.TenantPosition_Area_M2||'--') + ' m²</div>';
                html += '<div class="small text-muted">Toạ độ: ' + (data.TenantPosition_LeftPct||'--') + ' %, ' + (data.TenantPosition_TopPct||'--') + ' %</div>';
                html += '</div></div>';
                modalBody.innerHTML = html;
              })
              .catch(err => { console.error(err); modalBody.innerHTML = '<div class="p-3 text-danger">Không tải được dữ liệu.</div>'; });
            }
          }
        }

        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('click', onClick);

        // animation loop
        const clock = new THREE.Clock();
        function animate(){
          requestAnimationFrame(animate);
          const t = clock.getElapsedTime();
          elevatorsGroup.children.forEach(c => {
            if (c.geometry && c.geometry.type === 'ConeGeometry'){
              const s = 1.0 + 0.06 * Math.sin(t*4 + c.position.y);
              c.scale.set(s,s,s);
            }
          });
          controls.update();
          renderer.render(scene, camera);
          labelRenderer.render(scene, camera);
        }
        animate();

        // resize
        window.addEventListener('resize', () => {
          const w = container.clientWidth, h = container.clientHeight;
          camera.aspect = w/h; camera.updateProjectionMatrix();
          renderer.setSize(w,h); labelRenderer.setSize(w,h);
        });

        // expose reload3DPositions (if needed)
        window.reload3DPositions = function(newPositions){
          if (!Array.isArray(newPositions)) return;
          // replace allPositions content and rebuild
          allPositions.length = 0;
          newPositions.forEach(p => allPositions.push(p));
          applyFiltersFromSelect();
        };

    </script>
}
