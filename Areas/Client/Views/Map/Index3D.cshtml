@model Semester03.Areas.Client.Models.ViewModels.MapViewModel
@{
    Layout = "_LayoutClient";
    // physical & svg constants
    var shopHeightMeters = 5m;
    var elevatorHeightMeters = 8m;
    var planWidthMeters = 120m;
    var planDepthMeters = 80m;
    var vbW = 1200m; var vbH = 800m;
    var defaultRectW = 100m; var defaultRectH = 60m; // <-- same as Index
    var atrX = 460m; var atrY = 260m; var atrW = 280m; var atrH = 180m;
    var elevW = 48m;
    var elevH = atrH - 20m;
    var elevY = atrY + 10m;
    var elev1X = atrX + 20m;
    var elev2X = atrX + atrW - 20m - elevW;
    var wcX = 1020m; var wcY = 320m;

    var positions = Model?.Positions ?? new List<Semester03.Areas.Client.Models.ViewModels.TenantPositionDto>();
    var floorList = positions.Select(p => p.TenantPosition_Floor).Distinct().OrderBy(x => x).ToList();
    int? currentFloor = Model?.FloorNumber;
}

<div class="container py-3">
    <div class="d-flex justify-content-between align-items-center mb-2">
        <div>
            <h4 class="mb-0">Mô phỏng 3D sơ đồ — @(currentFloor.HasValue ? (currentFloor == 0 ? "G (0)" : "Tầng " + currentFloor.ToString()) : "Tất cả")</h4>
        </div>

        <div class="d-flex gap-2 align-items-center">
            <select id="floorSelect" class="form-select form-select-sm" style="min-width:160px;">
                <option value="ALL" @(currentFloor == null ? "selected" : "")>Tất cả tầng (Toàn Mall)</option>
                @foreach (var f in floorList)
                {
                    <option value="@f" @(currentFloor.HasValue && currentFloor.Value == f ? "selected" : "")>@(f == 0 ? "G (0)" : "Tầng " + f)</option>
                }
            </select>
        </div>
    </div>

    <div class="card p-0">
        <div id="threeContainer" style="height:820px; width:100%; position:relative;"></div>

        <div class="p-2">
            <div class="d-flex gap-3 align-items-center flex-wrap">
                <div class="form-check form-check-inline ms-auto">
                    <input class="form-check-input" type="checkbox" id="chkShowEmpty" checked>
                    <label class="form-check-label small" for="chkShowEmpty">Hiện vị trí trống</label>
                </div>

                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" id="chkShowOccupied" checked>
                    <label class="form-check-label small" for="chkShowOccupied">Hiện có tenant</label>
                </div>
            </div>
        </div>
    </div>
</div>

@* modal cho 3D click *@
<div class="modal fade" id="posModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-md modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Thông tin ô</h5>
                <button class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body" id="posModalBody">
                <div class="text-center py-3 text-muted">Đang tải...</div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" data-bs-dismiss="modal">Đóng</button>
            </div>
        </div>
    </div>
</div>

@section Styles {
    <style>
        /* Container / background */
        #threeContainer {
            border-radius: 8px;
            overflow: hidden;
            /* nhẹ nhàng hơn: gradient pastel, ít chói */
            background: linear-gradient(180deg, #f5f7fa 0%, #eef4f8 100%);
            box-shadow: 0 10px 26px rgba(10,20,30,0.05);
            border: 1px solid rgba(15,23,30,0.03);
        }

        /* Global card / panel */
        .card {
            border-radius: 10px;
            background-clip: padding-box;
            border: 1px solid rgba(15,23,30,0.04);
            box-shadow: 0 6px 18px rgba(15,23,30,0.04);
        }

        /* Form controls (dropdown / buttons) — slightly larger, softer */
        .form-select, .btn, .form-check-label {
            border-radius: 8px !important;
            font-size: 13px;
        }

        .form-select {
            border: 1px solid rgba(11,18,33,0.06) !important;
            background: linear-gradient(180deg,#ffffff,#f8fbff);
            box-shadow: none !important;
        }

        .btn-outline-primary {
            color: #0b4da1;
            border-color: rgba(11,77,161,0.12);
            background: linear-gradient(180deg,#ffffff,#f7fbff);
        }

        /* Labels that render above shops (CSS2D) — clearer but not harsh */
        .label-2d {
            font-family: Inter, Roboto, Arial, sans-serif;
            font-size: 13px;
            padding: 6px 10px;
            background: rgba(255,255,255,0.95); /* nearly opaque for legibility */
            border-radius: 8px;
            color: #0e2130; /* slightly softer than pure black */
            font-weight: 600;
            border: 1px solid rgba(6,12,20,0.06);
            box-shadow: 0 6px 18px rgba(6,12,20,0.06);
            pointer-events: auto;
            white-space: nowrap;
            transform-origin: center top;
        }

        /* Smaller label for WC etc */
        .label-wc {
            font-size: 12px;
            padding: 6px 8px;
            border-radius: 8px;
            background: rgba(255,245,245,0.98);
            color: #8b2b2b;
            font-weight: 700;
            border: 1px solid rgba(139,43,43,0.06);
            box-shadow: 0 4px 12px rgba(139,43,43,0.04);
        }

        /* make 3D hover effect more subtle */
        .label-2d:hover {
            transform: translateY(-4px) scale(1.01);
            transition: transform .12s ease;
            box-shadow: 0 9px 22px rgba(6,12,20,0.07);
        }

        /* SVG-style buttons/legend in page (if any) */
        .map-legend rect {
            stroke: rgba(10,20,40,0.04);
            fill: rgba(255,255,255,0.98);
        }

        /* reduce grid contrast (Three.js grid helper overlay is lighter already but be safe) */
        .three-grid-helper {
            opacity: 0.7;
            filter: blur(0.0px);
        }

        /* small screens */
        @@media (max-width: 767px) {
            #threeContainer

        {
            height: 520px;
        }

        .label-2d {
            font-size: 12px;
            padding: 5px 8px;
        }

        .form-select, .btn {
            font-size: 12px;
        }

        }

        /* Reduce visual clutter: smaller shadow on shop highlight */
        .shop-highlight {
            box-shadow: 0 8px 20px rgba(8,16,30,0.06);
            transition: transform .12s ease, box-shadow .12s ease;
        }

        /* subtle outline for selected shop in 3D (if you wish to add class) */
        .shop-selected {
            outline: 2px solid rgba(34,102,255,0.10);
            box-shadow: 0 12px 28px rgba(34,102,255,0.06);
        }

        /* accessibility: high-contrast focus ring for keyboard users */
        .form-select:focus, .btn:focus {
            box-shadow: 0 0 0 3px rgba(11,77,161,0.08);
            outline: none;
        }

        /* hide overly glossy bootstrap card backgrounds */
        .card .card-body {
            background: transparent;
        }
    </style>
}

@section Scripts {
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>

    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
            "three/examples/jsm/": "https://unpkg.com/three@0.154.0/examples/jsm/"
          }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer.js';

        // server-injected constants (numbers)
        const shopHeightMeters = @((double)shopHeightMeters);
        const elevatorHeightMeters = @((double)elevatorHeightMeters);
        const planWidthMeters = @((double)planWidthMeters);
        const planDepthMeters = @((double)planDepthMeters);
        const vbW = @((double)vbW);
        const vbH = @((double)vbH);
        const defaultRectW = @((double)defaultRectW);   // pixel units (same as Index)
        const defaultRectH = @((double)defaultRectH);
        const atrX = @((double)atrX);
        const atrY = @((double)atrY);
        const atrW = @((double)atrW);
        const atrH = @((double)atrH);
        const elevW = @((double)elevW);
        const elevH = @((double)elevH);
        const elevY = @((double)elevY);
        const elev1X = @((double)elev1X);
        const elev2X = @((double)elev2X);
        const wcX = @((double)wcX);
        const wcY = @((double)wcY);

        // positions and floor list
        const allPositions = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(positions));
        const floorList = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(floorList));
        let currentFloor = @(currentFloor.HasValue ? currentFloor.Value.ToString() : "null");

        // helpers: coords conversion
        function leftPctToX(leftPct){ return (leftPct/100.0) * planWidthMeters - planWidthMeters/2.0; }
        function topPctToZ(topPct){ return (topPct/100.0) * planDepthMeters - planDepthMeters/2.0; }
        function svgToMeterX(svgX){ return (svgX / vbW) * planWidthMeters - planWidthMeters/2.0; }
        function svgToMeterZ(svgY){ return (svgY / vbH) * planDepthMeters - planDepthMeters/2.0; }

        // atrium bounds (meters) for other uses
        const atriumWidthMeters = (atrW / vbW * planWidthMeters);
        const atriumDepthMeters = (atrH / vbH * planDepthMeters);
        const atriumCenterX = ((atrX + atrW/2.0) / vbW * planWidthMeters) - planWidthMeters/2.0;
        const atriumCenterZ = ((atrY + atrH/2.0) / vbH * planDepthMeters) - planDepthMeters/2.0;
        const atriumHalfW = atriumWidthMeters / 2.0;
        const atriumHalfD = atriumDepthMeters / 2.0;

        // Scene + renderers
        const container = document.getElementById('threeContainer');
        const scene = new THREE.Scene(); scene.background = new THREE.Color(0xf6fbff);

        const renderer = new THREE.WebGLRenderer({ antialias:true, physicallyCorrectLights:true });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(container.clientWidth, container.clientHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0';
        labelRenderer.domElement.style.left = '0';
        labelRenderer.domElement.style.pointerEvents = 'none';
        container.appendChild(labelRenderer.domElement);

        // Camera / controls
        const camera = new THREE.PerspectiveCamera(50, container.clientWidth/container.clientHeight, 0.1, 5000);
        camera.position.set(0, 160, 260);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.08;
        controls.screenSpacePanning = false;
        controls.minDistance = 40; controls.maxDistance = 1200;
        controls.maxPolarAngle = Math.PI * 0.49;
        controls.target.set(0, 30, 0);
        controls.update();

        // Lighting (softer)
        scene.add(new THREE.AmbientLight(0xffffff, 0.38));
        scene.add(new THREE.HemisphereLight(0xffffff, 0x515760, 0.22));
        const dir = new THREE.DirectionalLight(0xffffff, 0.85);
        dir.position.set(120,400,160);
        dir.castShadow = true;
        dir.shadow.mapSize.set(2048,2048);
        scene.add(dir);

        // ground + grid
        const groundGeom = new THREE.PlaneGeometry(planWidthMeters, planDepthMeters);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0xf8fbff, metalness:0.02, roughness:0.88 });
        const ground = new THREE.Mesh(groundGeom, groundMat); ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
        const grid = new THREE.GridHelper(Math.max(planWidthMeters, planDepthMeters), 12, 0xe9eef3, 0xe9eef3); grid.position.y = 0.01; scene.add(grid);

        // floor separators & skylight & full atrium walls
        const gap = 1.0;
        const maxFloor = (floorList && floorList.length>0) ? Math.max(...floorList,0) : 0;
        const floorsCount = Math.max(1, maxFloor + 1);
        const totalHeight = floorsCount * (shopHeightMeters + gap);

        const separatorsGroup = new THREE.Group(); scene.add(separatorsGroup);
        for (let f=1; f<=maxFloor; f++){
          const y = f * (shopHeightMeters + gap) - gap/2.0;
          const matVis = new THREE.MeshStandardMaterial({ color: 0x0b1724, transparent:true, opacity:0.09, side: THREE.DoubleSide, roughness:0.9 });
          const plane = new THREE.Mesh(new THREE.PlaneGeometry(planWidthMeters, planDepthMeters), matVis);
          plane.rotation.x = -Math.PI/2;
          plane.position.y = y;
          separatorsGroup.add(plane);
          // 2D label
          const div = document.createElement('div'); div.className='label-2d'; div.textContent = `Tầng ${f}`; div.style.fontSize='12px';
          const lbl = new CSS2DObject(div);
          lbl.position.set(-planWidthMeters/2 + 6, y + 0.4, -planDepthMeters/2 + 6);
          scene.add(lbl);
        }

        // Atrium walls + skylight spanning floors (same idea)
        (function addAtriumWallsAndSkylight(){
          const wallThickness = 0.6;
          const sideMat = new THREE.MeshStandardMaterial({ color:0xfff6eb, transparent:true, opacity:0.95, roughness:0.7 });
          const north = new THREE.Mesh(new THREE.BoxGeometry(atriumWidthMeters, totalHeight + 0.2, wallThickness), sideMat);
          north.position.set(atriumCenterX, (totalHeight)/2.0, atriumCenterZ - atriumHalfD + wallThickness/2); scene.add(north);
          const south = new THREE.Mesh(new THREE.BoxGeometry(atriumWidthMeters, totalHeight + 0.2, wallThickness), sideMat);
          south.position.set(atriumCenterX, (totalHeight)/2.0, atriumCenterZ + atriumHalfD - wallThickness/2); scene.add(south);
          const west = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, totalHeight + 0.2, atriumDepthMeters), sideMat);
          west.position.set(atriumCenterX - atriumHalfW + wallThickness/2, (totalHeight)/2.0, atriumCenterZ); scene.add(west);
          const east = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, totalHeight + 0.2, atriumDepthMeters), sideMat);
          east.position.set(atriumCenterX + atriumHalfW - wallThickness/2, (totalHeight)/2.0, atriumCenterZ); scene.add(east);

          // skylight (roof)
          const skylightMat = new THREE.MeshPhysicalMaterial({ color:0xeef8ff, transparent:true, opacity:0.12, roughness:0.06, clearcoat:0.2 });
          const skylight = new THREE.Mesh(new THREE.PlaneGeometry(atriumWidthMeters, atriumDepthMeters), skylightMat);
          skylight.rotation.x = -Math.PI/2;
          skylight.position.set(atriumCenterX, totalHeight + 0.6, atriumCenterZ);
          scene.add(skylight);

          const roofMat = new THREE.MeshStandardMaterial({ color: 0xf2f7fb, transparent:true, opacity:0.9, roughness:0.85 });
          const roof = new THREE.Mesh(new THREE.PlaneGeometry(planWidthMeters, planDepthMeters), roofMat);
          roof.rotation.x = -Math.PI/2;
          roof.position.set(0, totalHeight + 1.0, 0);
          scene.add(roof);
        })();

        // Elevators & WC (unchanged)
        const elevatorsGroup = new THREE.Group(); scene.add(elevatorsGroup);
        (function addElevatorsShafts(){
          const e1center = svgToMeterX(elev1X + elevW/2.0);
          const e2center = svgToMeterX(elev2X + elevW/2.0);
          const eZ = svgToMeterZ(elevY + elevH/2.0);
          const shaftGeom = new THREE.BoxGeometry(4, totalHeight + 0.4, 4.0);
          const shaftMat = new THREE.MeshStandardMaterial({ color:0x222a35, transparent:true, opacity:0.12, roughness:0.9 });
          const s1 = new THREE.Mesh(shaftGeom, shaftMat); s1.position.set(e1center, totalHeight/2.0, eZ); s1.receiveShadow=true; elevatorsGroup.add(s1);
          const s2 = new THREE.Mesh(shaftGeom, shaftMat); s2.position.set(e2center, totalHeight/2.0, eZ); s2.receiveShadow=true; elevatorsGroup.add(s2);
          const coneGeom = new THREE.ConeGeometry(1.2, 2.4, 16);
          const coneUpMat = new THREE.MeshStandardMaterial({ color:0x16a34a, emissive:0x16a34a, emissiveIntensity:0.18, roughness:0.6 });
          const coneDownMat = new THREE.MeshStandardMaterial({ color:0xf39c12, emissive:0xf39c12, emissiveIntensity:0.18, roughness:0.6 });
          for (let f=0; f< floorsCount; f++){
            const baseY = f * (shopHeightMeters + gap);
            const c1 = new THREE.Mesh(coneGeom, (f%2===0)?coneUpMat:coneDownMat);
            c1.position.set(e1center, baseY + shopHeightMeters + 0.8, eZ); if (f%2===0) c1.rotation.x = Math.PI;
            elevatorsGroup.add(c1);
            const c2 = new THREE.Mesh(coneGeom, (f%2===0)?coneUpMat:coneDownMat);
            c2.position.set(e2center, baseY + shopHeightMeters + 0.8, eZ); if (f%2===0) c2.rotation.x = Math.PI;
            elevatorsGroup.add(c2);
          }
        })();

        const wcGroup = new THREE.Group(); scene.add(wcGroup);
        (function addWCPerFloor(){
          const wcXm = svgToMeterX(wcX);
          const wcZm = svgToMeterZ(wcY);
          for (let f=0; f< floorsCount; f++){
            const baseY = f * (shopHeightMeters + gap);
            const geom = new THREE.BoxGeometry(6, 3.0, 4.0);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffecec, metalness:0.0, roughness:0.5 });
            const wc = new THREE.Mesh(geom, mat); wc.position.set(wcXm, baseY + 1.5, wcZm);
            wc.userData = { type:'wc', floor: f }; wc.receiveShadow=true; wc.castShadow=true;
            wcGroup.add(wc);
            const div = document.createElement('div'); div.className='label-wc'; div.textContent = 'WC';
            const lbl = new CSS2DObject(div); lbl.position.set(0, 1.8, 0); wc.add(lbl);
          }
        })();

        // ---------------------------
        // SHOPS: use SVG-placement algorithm (same as Index) then map to 3D
        // ---------------------------

        // helper to remove CSS2D DOM elements attached to objects (recursive)
        function remove2DLabelsRecursively(obj){
          if (!obj) return;
          if (obj.element && obj.element.parentNode){
            try { obj.element.parentNode.removeChild(obj.element); } catch(e){ }
          }
          if (obj.children && obj.children.length){
            for (let i=0;i<obj.children.length;i++) remove2DLabelsRecursively(obj.children[i]);
          }
        }

        let shopsGroup = null;
        function createNewShopsGroup(){
          if (shopsGroup){
            shopsGroup.children.forEach(c => remove2DLabelsRecursively(c));
            shopsGroup.traverse(node => {
              if (node.geometry){ node.geometry.dispose(); }
              if (node.material){ if (Array.isArray(node.material)) node.material.forEach(m => m.dispose && m.dispose()); else node.material.dispose && node.material.dispose(); }
            });
            scene.remove(shopsGroup);
            shopsGroup = null;
          }
          shopsGroup = new THREE.Group();
          scene.add(shopsGroup);
          return shopsGroup;
        }

        // this function replicates Index placement exactly:
        function buildShops(forFloorsArray){
          createNewShopsGroup();

          // pick positions to render
          let list = [];
          if (!forFloorsArray || forFloorsArray.length === 0){
            if (currentFloor !== null) list = allPositions.filter(p => parseInt((p.TenantPosition_Floor === undefined || p.TenantPosition_Floor === null) ? 0 : p.TenantPosition_Floor) === parseInt(currentFloor));
            else list = allPositions.slice();
          } else {
            list = allPositions.filter(p => forFloorsArray.includes(parseInt((p.TenantPosition_Floor === undefined || p.TenantPosition_Floor === null) ? 0 : p.TenantPosition_Floor)));
          }

          // placed boxes in SVG coords (top-left x,y,w,h)
          const placedBoxes = [];
          // offsets same as Index
          const offsets = [ [0,0],[8,0],[-8,0],[0,8],[0,-8],[12,12],[-12,12],[12,-12],[-12,-12] ];

          // forbidden rectangles in SVG coords (same as Index)
          const forbiddenRects = [
            {x: atrX, y: atrY, w: atrW, h: atrH, name:'atrium'},
            {x: elev1X, y: elevY, w: elevW, h: elevH, name:'elev1'},
            {x: elev2X, y: elevY, w: elevW, h: elevH, name:'elev2'},
            {x: wcX, y: wcY, w: 44, h:44, name:'wc'}
          ];

          function overlaps(ax, ay, aw, ah){
            // check against already placed
            for (let i=0;i<placedBoxes.length;i++){
              const b = placedBoxes[i];
              if (!(ax + aw <= b.x || b.x + b.w <= ax || ay + ah <= b.y || b.y + b.h <= ay)) return true;
            }
            // check forbidden
            for (let j=0;j<forbiddenRects.length;j++){
              const fr = forbiddenRects[j];
              if (!(ax + aw <= fr.x || fr.x + fr.w <= ax || ay + ah <= fr.y || fr.y + fr.h <= ay)) return true;
            }
            return false;
          }

          // process each dto in same order as Index
          for (let idx=0; idx<list.length; idx++){
            const p = list[idx];
            // skip if coords missing
            if (p.TenantPosition_LeftPct === undefined || p.TenantPosition_TopPct === undefined) continue;
            const leftPct = Math.max(0, Math.min(100, parseFloat(p.TenantPosition_LeftPct)));
            const topPct = Math.max(0, Math.min(100, parseFloat(p.TenantPosition_TopPct)));
            const cx = leftPct / 100.0 * vbW;
            const cy = topPct / 100.0 * vbH;
            const w = defaultRectW;
            const h = defaultRectH;
            let rx = cx - w/2.0;
            let ry = cy - h/2.0;
            const minX = 8.0, minY = 8.0;
            const maxX = vbW - w - 8.0, maxY = vbH - h - 8.0;
            rx = Math.max(minX, Math.min(maxX, rx));
            ry = Math.max(minY, Math.min(maxY, ry));

            let placed = false;
            for (let oi=0; oi<offsets.length; oi++){
              let candX = rx + offsets[oi][0];
              let candY = ry + offsets[oi][1];
              candX = Math.max(minX, Math.min(maxX, candX));
              candY = Math.max(minY, Math.min(maxY, candY));
              if (!overlaps(candX, candY, w, h)){
                placedBoxes.push({x:candX, y:candY, w:w, h:h, id: p.TenantPosition_ID});
                // map to 3D meters: use center of placed rect
                const centerX = candX + w/2.0;
                const centerY = candY + h/2.0;
                const placedMetersX = svgToMeterX(centerX);
                const placedMetersZ = svgToMeterZ(centerY);
                addShopMesh(p, placedMetersX, placedMetersZ);
                placed = true;
                break;
              }
            }
            if (!placed){
              // fallback: shift along Y until fit (same as Index)
              let tryX = Math.max(minX, Math.min(maxX, rx));
              let tryY = Math.max(minY, Math.min(maxY, ry));
              let attempts = 0;
              while (overlaps(tryX, tryY, w, h) && attempts < 40){
                tryY += 8.0;
                if (tryY > maxY) tryY = minY;
                attempts++;
              }
              placedBoxes.push({x:tryX, y:tryY, w:w, h:h, id: p.TenantPosition_ID});
              const centerX = tryX + w/2.0;
              const centerY = tryY + h/2.0;
              const placedMetersX = svgToMeterX(centerX);
              const placedMetersZ = svgToMeterZ(centerY);
              addShopMesh(p, placedMetersX, placedMetersZ);
            }
          } // end for each list
        } // end buildShops

        // create and add 3D shop mesh at given meters center
        function addShopMesh(p, centerMetersX, centerMetersZ){
          const area = parseFloat(p.TenantPosition_Area_M2 ?? 150);
          const assigned = !!(p.TenantPosition_AssignedTenantID && p.TenantPosition_AssignedTenantID > 0);
          const labelText = (p.Tenant && p.Tenant.Tenant_Name) ? p.Tenant.Tenant_Name : (p.TenantPosition_Location || "Trống");

          const w = Math.max(6.0, Math.sqrt(area) * 0.9);
          const d = Math.max(4.0, area / w);
          const h = shopHeightMeters;
          const geom = new THREE.BoxGeometry(w, h, d);
          const mat = new THREE.MeshStandardMaterial({ color: assigned ? 0x2b6cb0 : 0xffffff, roughness:0.48, metalness:0.02 });
          const mesh = new THREE.Mesh(geom, mat); mesh.castShadow=true; mesh.receiveShadow=true;

          // map centerMetersX/Z are centers; set Y by floor from data
          const floor = parseInt((p.TenantPosition_Floor === undefined || p.TenantPosition_Floor === null) ? 0 : p.TenantPosition_Floor);
          const baseY = floor * (shopHeightMeters + gap);
          mesh.position.set(centerMetersX, baseY + h/2.0, centerMetersZ);
          mesh.userData = { id: p.TenantPosition_ID, floor: floor, assigned: assigned, label: labelText };

          // label
          const div = document.createElement('div'); div.className='label-2d'; div.textContent = `Tầng ${floor} - ${labelText}`;
          const label = new CSS2DObject(div);
          label.position.set(0, h/2 + 0.6, 0);
          mesh.add(label);

          shopsGroup.add(mesh);
        }

        // ---------------------------
        // UI: select + checkboxes (robust)
        // ---------------------------
        const floorSelect = document.getElementById('floorSelect');
        const chkShowEmpty = document.getElementById('chkShowEmpty');
        const chkShowOcc = document.getElementById('chkShowOccupied');

        function getSelectedFloorsFromSelect(){
          if (!floorSelect) return (currentFloor !== null) ? [parseInt(currentFloor)] : [];
          const val = floorSelect.value;
          if (!val) return (currentFloor !== null) ? [parseInt(currentFloor)] : [];
          if (String(val).toUpperCase() === 'ALL') return [];
          const n = parseInt(val);
          return isNaN(n) ? [] : [n];
        }

        function applyFiltersFromSelect(){
          if (floorSelect){
            currentFloor = (String(floorSelect.value).toUpperCase() === 'ALL') ? null : (isNaN(parseInt(floorSelect.value)) ? null : parseInt(floorSelect.value));
          }
          const floors = getSelectedFloorsFromSelect();
          buildShops(floors);

          const showEmpty = chkShowEmpty ? chkShowEmpty.checked : true;
          const showOcc = chkShowOcc ? chkShowOcc.checked : true;
          if (shopsGroup && shopsGroup.children){
            shopsGroup.children.forEach(m => {
              const assigned = m.userData && m.userData.assigned;
              let visible = true;
              if (!showEmpty && !assigned) visible = false;
              if (!showOcc && assigned) visible = false;
              m.visible = visible;
            });
          }
        }

        // init defaults
        if (floorSelect){
          if (currentFloor !== null) floorSelect.value = String(currentFloor); else {
            try { floorSelect.querySelector('option[value="ALL"]').selected = true; } catch(e) {}
          }
          applyFiltersFromSelect();
        }

        if (floorSelect) floorSelect.addEventListener('change', applyFiltersFromSelect);
        if (chkShowEmpty) chkShowEmpty.addEventListener('change', applyFiltersFromSelect);
        if (chkShowOcc) chkShowOcc.addEventListener('change', applyFiltersFromSelect);

        // Raycast hover & click (uses the shopsGroup variable which we recreate safely)
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let hovered = null;
        const modal = new bootstrap.Modal(document.getElementById('posModal'));
        const modalBody = document.getElementById('posModalBody');

        function onPointerMove(e){
          const rect = renderer.domElement.getBoundingClientRect();
          pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
          pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
          raycaster.setFromCamera(pointer, camera);
          if (!shopsGroup) return;
          const intersects = raycaster.intersectObjects(shopsGroup.children, true);
          if (intersects.length > 0){
            const mesh = intersects[0].object;
            if (hovered !== mesh){
              clearHover(); setHover(mesh);
            }
          } else clearHover();
        }

        function setHover(mesh){
          if (!mesh || !mesh.userData) return;
          hovered = mesh;
          if (mesh.material && mesh.material.emissive !== undefined){
            mesh.userData.prevEm = mesh.material.emissive.clone();
            mesh.material.emissive.setHex(0x2266ff);
          } else if (mesh.material && mesh.material.color){
            mesh.userData.prevColor = mesh.material.color.getHex();
            mesh.material.color.setHex(0xffe58a);
          }
          mesh.userData.prevScale = mesh.scale.clone();
          mesh.scale.set(mesh.scale.x*1.04, mesh.scale.y*1.04, mesh.scale.z*1.04);
          renderer.domElement.style.cursor = 'pointer';
        }

        function clearHover(){
          if (!hovered) return;
          const m = hovered;
          if (m.material && m.material.emissive !== undefined && m.userData.prevEm){
            m.material.emissive.copy(m.userData.prevEm);
            delete m.userData.prevEm;
          }
          if (m.material && m.material.color && m.userData.prevColor){
            m.material.color.setHex(m.userData.prevColor);
            delete m.userData.prevColor;
          }
          if (m.userData.prevScale) { m.scale.copy(m.userData.prevScale); delete m.userData.prevScale; }
          hovered = null; renderer.domElement.style.cursor = 'default';
        }

        function onClick(e){
          if (!shopsGroup) return;
          const rect = renderer.domElement.getBoundingClientRect();
          pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
          pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
          raycaster.setFromCamera(pointer, camera);
          const intersects = raycaster.intersectObjects(shopsGroup.children, true);
          if (intersects.length > 0){
            const mesh = intersects[0].object;
            const id = mesh.userData && mesh.userData.id;
            if (id && id>0){
              const url = '@Url.Action("GetPositionJson", "Map", new { area = "Client" })';
              modalBody.innerHTML = '<div class="text-center py-3"><div class="spinner-border text-primary" role="status"></div><div class="mt-2 text-muted">Đang tải...</div></div>';
              modal.show();
              fetch(url + '?id=' + id).then(r=>{ if(!r.ok) throw new Error('notfound'); return r.json(); })
              .then(data => {
                let html = '<div class="d-flex gap-3">';
                if (data.Tenant && data.Tenant.Tenant_Img) html += '<div style="flex:0 0 96px"><img src="' + data.Tenant.Tenant_Img + '" class="img-fluid rounded" /></div><div style="flex:1">';
                else html += '<div style="flex:1">';
                html += '<h5 class="mb-1">' + (data.Tenant && data.Tenant.Tenant_Name ? data.Tenant.Tenant_Name : (data.TenantPosition_Location || 'Vị trí')) + '</h5>';
                if (data.Tenant && data.Tenant.Tenant_Description) html += '<div class="text-muted small mb-2">' + data.Tenant.Tenant_Description + '</div>';
                if (data.Tenant && data.Tenant.TenantType_Name) html += '<div class="small text-secondary">Loại: ' + data.Tenant.TenantType_Name + '</div>';
                html += '<div class="small text-muted mt-2">Diện tích: ' + (data.TenantPosition_Area_M2||'--') + ' m²</div>';
                html += '<div class="small text-muted">Toạ độ: ' + (data.TenantPosition_LeftPct||'--') + ' %, ' + (data.TenantPosition_TopPct||'--') + ' %</div>';
                html += '</div></div>';
                modalBody.innerHTML = html;
              })
              .catch(err => { console.error(err); modalBody.innerHTML = '<div class="p-3 text-danger">Không tải được dữ liệu.</div>'; });
            }
          }
        }

        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('click', onClick);

        // animation loop
        const clock = new THREE.Clock();
        function animate(){
          requestAnimationFrame(animate);
          const t = clock.getElapsedTime();
          elevatorsGroup.children.forEach(c => {
            if (c.geometry && c.geometry.type === 'ConeGeometry'){
              const s = 1.0 + 0.06 * Math.sin(t*4 + c.position.y);
              c.scale.set(s,s,s);
            }
          });
          controls.update();
          renderer.render(scene, camera);
          labelRenderer.render(scene, camera);
        }
        animate();

        // resize
        window.addEventListener('resize', () => {
          const w = container.clientWidth, h = container.clientHeight;
          camera.aspect = w/h; camera.updateProjectionMatrix();
          renderer.setSize(w,h); labelRenderer.setSize(w,h);
        });

        // expose reload3DPositions (if needed)
        window.reload3DPositions = function(newPositions){
          if (!Array.isArray(newPositions)) return;
          allPositions.length = 0;
          newPositions.forEach(p => allPositions.push(p));
          applyFiltersFromSelect();
        };

    </script>
}